[开篇词 | 你为什么需要学习并发编程？](https://time.geekbang.org/column/article/83087?device=geekTime.ios)

[学习攻略 | 如何才能学好并发编程？](https://time.geekbang.org/column/article/83267?device=geekTime.ios)

[01 | 可见性、原子性和有序性问题：并发编程Bug的源头](https://time.geekbang.org/column/article/83682?device=geekTime.ios)

[02 | Java内存模型：看Java如何解决可见性和有序性问题](https://time.geekbang.org/column/article/84017?device=geekTime.ios)

[03 | 互斥锁（上）：解决原子性问题](https://time.geekbang.org/column/article/84344?device=geekTime.ios)

[04 | 互斥锁（下）：如何用一把锁保护多个资源？](https://time.geekbang.org/column/article/84601?device=geekTime.ios)

[05 | 一不小心就死锁了，怎么办？](https://time.geekbang.org/column/article/85001?device=geekTime.ios)

[06 | 用“等待-通知”机制优化循环等待](https://time.geekbang.org/column/article/85241?device=geekTime.ios)

[07 | 安全性、活跃性以及性能问题](https://time.geekbang.org/column/article/85702?device=geekTime.ios)

[08 | 管程：并发编程的万能钥匙](https://time.geekbang.org/column/article/86089?device=geekTime.ios)

[09 | Java线程（上）：Java线程的生命周期](https://time.geekbang.org/column/article/86366?device=geekTime.ios)

[10 | Java线程（中）：创建多少线程才是合适的？](https://time.geekbang.org/column/article/86666?device=geekTime.ios)

[11 | Java线程（下）：为什么局部变量是线程安全的？](https://time.geekbang.org/column/article/86695?device=geekTime.ios)

[12 | 如何用面向对象思想写好并发程序？](https://time.geekbang.org/column/article/87365?device=geekTime.ios)

[13 | 理论基础模块热点问题答疑](https://time.geekbang.org/column/article/87749?device=geekTime.ios)

[14 | Lock和Condition（上）：隐藏在并发包中的管程](https://time.geekbang.org/column/article/87779?device=geekTime.ios)

[15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？](https://time.geekbang.org/column/article/88487?device=geekTime.ios)

[16 | Semaphore：如何快速实现一个限流器？](https://time.geekbang.org/column/article/88499?device=geekTime.ios)

[17 | ReadWriteLock：如何快速实现一个完备的缓存？](https://time.geekbang.org/column/article/88909?device=geekTime.ios)

[18 | StampedLock：有没有比读写锁更快的锁？](https://time.geekbang.org/column/article/89456?device=geekTime.ios)

[19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？](https://time.geekbang.org/column/article/89461?device=geekTime.ios)

[20 | 并发容器：都有哪些“坑”需要我们填？](https://time.geekbang.org/column/article/90201?device=geekTime.ios)

[21 | 原子类：无锁工具类的典范](https://time.geekbang.org/column/article/90515?device=geekTime.ios)

[22 | Executor与线程池：如何创建正确的线程池？](https://time.geekbang.org/column/article/90771?device=geekTime.ios)

[23 | Future：如何用多线程实现最优的“烧水泡茶”程序？](https://time.geekbang.org/column/article/91292?device=geekTime.ios)

[24 | CompletableFuture：异步编程没那么难](https://time.geekbang.org/column/article/91569?device=geekTime.ios)

[25 | CompletionService：如何批量执行异步任务？](https://time.geekbang.org/column/article/92245?device=geekTime.ios)

[26 | Fork/Join：单机版的MapReduce](https://time.geekbang.org/column/article/92524?device=geekTime.ios)

[27 | 并发工具类模块热点问题答疑](https://time.geekbang.org/column/article/92849?device=geekTime.ios)

[28 | Immutability模式：如何利用不变性解决并发问题？](https://time.geekbang.org/column/article/92856?device=geekTime.ios)

[29 | Copy-on-Write模式：不是延时策略的COW](https://time.geekbang.org/column/article/93154?device=geekTime.ios)

[30 | 线程本地存储模式：没有共享，就没有伤害](https://time.geekbang.org/column/article/93745?device=geekTime.ios)

[31 | Guarded Suspension模式：等待唤醒机制的规范实现](https://time.geekbang.org/column/article/94097?device=geekTime.ios)

[32 | Balking模式：再谈线程安全的单例模式](https://time.geekbang.org/column/article/94604?device=geekTime.ios)

[33 | Thread-Per-Message模式：最简单实用的分工方法](https://time.geekbang.org/column/article/95098?device=geekTime.ios)

[34 | Worker Thread模式：如何避免重复创建线程？](https://time.geekbang.org/column/article/95525?device=geekTime.ios)

[35 | 两阶段终止模式：如何优雅地终止线程？](https://time.geekbang.org/column/article/95847?device=geekTime.ios)

[36 | 生产者-消费者模式：用流水线思想提高效率](https://time.geekbang.org/column/article/96168?device=geekTime.ios)

[37 | 设计模式模块热点问题答疑](https://time.geekbang.org/column/article/96736?device=geekTime.ios)

[38 | 案例分析（一）：高性能限流器Guava RateLimiter](https://time.geekbang.org/column/article/97231?device=geekTime.ios)

[39 | 案例分析（二）：高性能网络应用框架Netty](https://time.geekbang.org/column/article/97622?device=geekTime.ios)

[40 | 案例分析（三）：高性能队列Disruptor](https://time.geekbang.org/column/article/98134?device=geekTime.ios)

[41 | 案例分析（四）：高性能数据库连接池HiKariCP](https://time.geekbang.org/column/article/98491?device=geekTime.ios)

